<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>UNIDEP-Arquitectura De Computadoras</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>UNIDEP</h1>
					<h3>JOSE MANUEL ZAVALA CARDENAS </h3>
					<p>
						<!--<small>Created by <a href="http://hakim.se">Hakim El Hattab</a> / <a href="http://twitter.com/hakimel">@hakimel</a></small>-->
					</p>
				</section>

				<section>
					<h2>UNIDAD 1 Y 2</h2>
					<h3>SISTEMAS OPERATIVOS ENTRADA/SALIDA</H3>
					<p>
					<img src="img/rf.jpg" width="300" height="300"	
					</p>

					<aside class="notes">
						Oh hey, these are some notes. They'll be hidden in your presentation, but you can see them if you open the speaker notes window (hit 's' on your keyboard).
					</aside>
				</section>

				<!-- Example of nested vertical slides -->
				<section>
						<h2>Entrada/Salida</h2>
						<p>
							<li>Introducción</ul>
							<li>Caracterización de los dispositivos de Entrada/Salida</ul>
							<li>Arquitectura del sistema de Entrada/Salida</ul>
						</p>
				</section>		
					
					<section>
						<h2>Introducción</h2>
						<p>El corazón de una computadora lo constituye el CPU.
						Sin embargo, no serviría de nada sin:</p>
						<p>
						<li>Dispositivos de almacenamiento secundario (discos) y terciario (cintas, CD, DVD).</ul>
						<li>Dispositivos periféricos que le permiten interactuar con el usuario.</ul>
						</p>
					</section>

					<section>
						<h2>Clasificación de los dispositivos de E/S</h2>
						<p><font color="black">Periféricos</font></p>
						<li>Legibles para el usuario</ul>
						<li>Permiten la comunicación entre el usuario y la computadora, ya sea de entrada (ratón, teclado, etc.) o salida (pantalla, impresora, etc.).</ul>
						<p><font color="black">Dispositivos de almacenamiento</font></p>
						<li>Legibles para la máquina</ul>
						<li>Proporcionan almacenamiento no volátil de datos para abastecer a los programas que ejecuta el CPU.</ul>
						<p><font color="black">Dispositivos de comunicaciones</font></p>
						<li>Permiten conectar a la computadora con otras computadoras a través de una red. </ul>
	
					</section>
					<section>
						<h2>Velocidad de los dispositivos</h2>
						<p>El CPU procesa instrucciones a mas de 1 GHz y la memoria RAM tiene un tiempo de acceso de nanosegundos.
Los dispositivos de E/S más rápidos tienen una velocidad del orden de los milisegundos.
Esta diferencia en la velocidad de acceso, y el hecho de que las aplicaciones son cada vez más interactivas y necesitan más E/S, hace que los sistemas de E/S sean el cuello de botella más importante de los sistemas. Por ello los SO dedican un gran esfuerzo en desarrollar y optimizar los mecanismos de E/S.</p>
						
					</section>
				</section>

				<section>
					<h3>El SO debe controlar el funcionamiento de todos los dispositivos de E/S para alcanzar los siguientes objetivos:</h3>
					<p>
					<li>Facilitar el manejo de los dispositivos periféricos. Para ello debe ofrecer una interfaz entre los dispositivos y el resto del sistema que sea sencilla y fácil de utilizar.</ul>
					<li>Optimizar la E/S del sistema, proporcionando mecanismos de incremento de prestaciones donde sea necesario.</ul>
					<li>Proporcionar dispositivos virtuales que permitan conectar cualquier tipo de dispositivo físico sin que sea necesario remodelar el sistema de E/S del SO.</ul>
					<li>Permitir la conexión de dispositivos nuevos de E/S, solventando de forma automática su instalación usando mecanismos del tipo plug&play. </ul>
					</p>
				</section>

				<section>
					<h2>Caracterización de los dispositivos de E/S</h2>
					<p>
					<li>Para los programadores, el sistema de E/S es una caja negra que lee y escribe datos en dispositivos externos a través de una funcionalidad bien definida.</ul>
					<li>Para los fabricantes de dispositivos, un dispositivo es un instrumento muy complejo que incluye cientos de miles de componentes electrónicos o electro-mecánicos.</ul>
					<li>Los diseñadores de SO se encuentran en un lugar intermedio entre los dos anteriores.</ul>
					</p>
					
				</section>

				<section>
					<h2>Conexión de dispositivos del sistema de E/S</h2>
					<p>
						En el modelo de un periférico se distinguen dos elementos:
					</p>
					<font color="black">Periféricos o dispositivos de E/S</font>
					<li>Elementos que se conectan al CPU a través de la unidades de E/S.</ul>
					<li>Son el componente mecánico que se “conecta” a la computadora.</ul>
					<p>
					<font color="black">Controladores de dispositivos o unidades de E/S</font>
					<li>Se encargan de hacer la transferencia de información entre la memoria principal y los periféricos.</ul>
					<li>Son el componente electrónico a través del cual se conecta el dispositivo de E/S.</ul>
					
					</p>
				
				</section>

				<section>
					<h2><font color="black">Conexión de dispositivos a una computadora</font></h2>
					<p>
					<img src="img/ki.jpg" width="500" height="400"
					</p>
				</section>

				<section>
					<h2>Conexión por puerto o memoria</h2>
					<p>
					Para iniciar una operación de E/S, el CPU tiene que escribir sobre los registros (datos, control, estado) los datos de la operación a través de una dirección de E/S o de memoria asignada únicamente al controlador.
					<li>El modelo de dispositivos por puerto </ul>
					<li>El modelo proyectado en memoria </ul>
					</p>
				</section>


				<section>
					<h2>El modelo de dispositivos por puerto es clásico de las arquitecturas Intel.</h2>
					<p>
						Cuando se instala un dispositivo, a su controlador se le asigna un puerto de E/S, una interrupción de hardware y un vector de interrupción.
						En una operación de E/S el CPU la ejecuta operaciones del tipo portin o portout con la dirección del puerto del dispositivo y con parámetros para indicar que puerto se desea manipular.
						El problema de este tipo de direccionamiento es que exige conocer las direcciones de E/S y programar las instrucciones especiales de E/S, lo que es significativamente distinto del modelo de memoria.

					</p>
				</section>

				<section>
					<h3><font color="black">El modelo proyectado en memoria asigna a cada dispositivo de E/S un rango de direcciones de memoria a través de las cuales se escribe sobre los registros del controlador</font></h3>
					<p>
						No hay instrucciones específicas de E/S, sino que las operaciones se llevan a cabo usando instrucciones máquina del manejo de memoria.
						Mapa único de direcciones de memoria
						Se reserva una zona de memoria física para asignar las direcciones de E/S.
					</p>
				</section>

				

				<section>
					<h2>Direcciones de E/S de algunos controladores en una PC con WinXP</h2>
					<p>
						<img src="img/bh.jpg" width="700" height="500"
					</p>
				</section>

				<section data-transition="linear" data-background="#8c4738" data-background-transition="slide">
					<h2>Dispositivos de bloques y caracteres </h2>
					<p>
						Dispositivos de bloque:
						<li>Acceso a nivel de bloque, el cual puede ser secuencial o aleatorio.</ul>
						<li>Operaciones: leer, escribir, buscar, …, etc.</ul>
						<li>E/S directa o a través del servidor de archivos.</ul>
						</P>
						<p>
						Dispositivos de caracter:
						<li>Acceso a nivel carácter, el cual también puede ser secuencial o aleatorio.</ul>
						<li>Existen bibliotecas para optimizar y dar forma a este tipo de accesos (edición de línea).</ul>
					</p>
				</section>

				<section>
					<h2>E/S por interrupciones</h2>
					<p>
					El procesador envía la orden de E/S al controlador del dispositivo y no espera, se dedica a otras tareas hasta que le llega una interrupción del dispositivo que indica que se ha realizado la operación solicitada.
					El gestor de interrupciones recibe y maneja la interrupción
					</p>	
				</section>

				<section>
					<h2>Rutinas de tratamiento de interrupción</h2>
					<p>
					Suelen tener dos partes:
					Una genérica y otra particular para el dispositivo
					<li>La parte genérica hace:</ul>
					</p>
					<p>
					Capturar la interrupción,
					Salvaguardar el estado del procesador,
					Activar la rutina de manejo de interrupción,
					Indicar al planificador que debe poner “lista” la rutina particular.
					Desactivar la interrupción,
					Restaurar el estado del procesador,
					Cesión de control
					</p>


			
				</section>

				<section>
					
					<p>
						La parte correspondiente a lo particular del dispositivo contiene el manejador que el fabricante desarrolló para manipular su dispositivo.

					</p>
				</section>

				

				<section>
					<h2>Interrupciones asociadas a algunos controladores en una PC</h2>
					<p>
					<img src="img/lolo.jpg" width="700" height="500"
					</p>
					</section>

				<section>
					<h2>Mecanismos de incremento de prestaciones</h2>
					<p>
						<img src="img/Imagen1.jpg" width="700" height="500"
					</p>
				</section>

				<section>
					<h2>Estructura y componentes</h2>
					<p>
					<img src="img/hy.jpg" width="700" height="500"
					</p>
				</section>

				<section>
					<h3>Diagrama de flujo con las operaciones de un manejador</h3>
					<p>
					<img src="img/dede.jpg" width="600" height="400"
					</p>
				</section>
				
				<section>
					<h1>Gracias...</h1>
					
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
